/* 
 * File:   main.c
 * Author: Jake
 *
 * Created on May 2, 2013, 10:29 PM
 */

#include "prototypes.h"
#include "misc.h"
#include "uart_setup.h"
#include "adc_setup.h"


// enumerated type for state machine
enum sender_state{connecting, connected_waiting, command_active};
enum sender_state system_state;

// PIC24EP256GP204 Configuration Bit Settings


/*
#include <xc.h>

// FICD

#pragma config ICS = PGD3               // ICD Communication Channel Select bits (Communicate on PGEC3 and PGED3)
#pragma config JTAGEN = OFF             // JTAG Enable bit (JTAG is disabled)

// FPOR
#pragma config ALTI2C1 = OFF            // Alternate I2C1 pins (I2C1 mapped to SDA1/SCL1 pins)
#pragma config ALTI2C2 = OFF            // Alternate I2C2 pins (I2C2 mapped to SDA2/SCL2 pins)
#pragma config WDTWIN = WIN25           // Watchdog Window Select bits (WDT Window is 25% of WDT period)

// FWDT
#pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler bits (1:32,768)
#pragma config WDTPRE = PR128           // Watchdog Timer Prescaler bit (1:128)
#pragma config PLLKEN = ON              // PLL Lock Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
#pragma config WINDIS = OFF             // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
#pragma config FWDTEN = OFF              // Watchdog Timer Enable bit (Watchdog timer always enabled)

// FOSC
#pragma config POSCMD = XT              // Primary Oscillator Mode Select bits (XT Crystal Oscillator Mode)
#pragma config OSCIOFNC = OFF           // OSC2 Pin Function bit (OSC2 is clock output)
#pragma config IOL1WAY = ON             // Peripheral pin select configuration (Allow only one reconfiguration)
#pragma config FCKSM = CSDCMD           // Clock Switching Mode bits (Both Clock switching and Fail-safe Clock Monitor are disabled)


// FOSCSEL
#pragma config FNOSC = PRIPLL              // Oscillator Source Selection (Primary Oscillator with PLL module (XT + PLL, HS + PLL, EC + PLL))
#pragma config IESO = ON                // Two-speed Oscillator Start-up Enable bit (Start up device with FRC, then switch to user-selected oscillator source)

// FGS
#pragma config GWRP = OFF               // General Segment Write-Protect bit (General Segment may be written)
#pragma config GCP = OFF                // General Segment Code-Protect bit (General Segment Code protect is Disabled)


// The above was code generated by MPLAB using the Configuration bits window
*/


/*
 * 
 * We need to
 * 1. Get a demo up of current pin breakout
 * 2. Setup UART
 * 3. Port over functions from PIC32 development
 *
 */

#define WAIT 50

char data;
char send_data;
char send_string[32] = "Hello World!";
char string[32];
int next;
int read_index;
int timer;
int wait_hold;
int timer_en;


int batt_check;
int batt_count;
int battery;

_FICD(ICS_PGD3 & JTAGEN_OFF)
_FPOR(ALTI2C1_ON & ALTI2C2_ON & WDTWIN_WIN25)
_FWDT(WDTPOST_PS32768 & WDTPRE_PR128 & PLLKEN_ON & WINDIS_OFF & FWDTEN_OFF)
_FOSC(POSCMD_XT & OSCIOFNC_OFF & IOL1WAY_ON & FCKSM_CSDCMD)
_FOSCSEL(FNOSC_PRIPLL & IESO_ON)
_FGS(GWRP_OFF & GCP_OFF)





int main(int argc, char** argv)
{
	// Initially check the battery voltage
	batt_check = 1;
    read_index = 0;
    next = 0;

    configureOscillator();
    configureINT();
    setupUART2();
    configureUART2pins();
    configureT1();
    setupLEDs();
    setupButtons();
    setupADC1();
    // Configures miscellanious digital/analog inputs
    setupIO();

    LED0 = 1;
    LED1 = 1;
    LED2 = 1;
    LED3 = 1;
    LED4 = 1;

    // make sure gate is closed
    BATTERY_CHECK_GATE = 0;

    // Turn on the timer
    T1CONbits.TON = 1;

    // Wait for Blueooth module to power up
    delay(4000);

    LED0 = 0;
    LED1 = 0;
    LED2 = 0;
    LED3 = 0;
    while(wait_hold == 0);
    LED0 = 1;
    LED1 = 1;
    LED2 = 1;
    LED3 = 1;


	battery = checkBatteryVoltage();

    // Reset the buffer
    memset(string,0,32);
    // Reset index
    read_index = 0;

    // send dollar signs to enter command mode
    char send1[] = "$$$";

    SerialTransmit(send1);

    // TODO: make this only try for a certain amount of time using the timer
    while(strcmp(string,"CMD\r\n") != 0);


    wait(100);

    // Reset the buffer
    memset(string,0,32);
    // Reset index
    read_index = 0;

    SerialTransmit("GB\n");
    // wait for response
    while(strcmp(string,"0006664FAE62\r\n") != 0);

    char dev_id[] = "0006664FAE62\r\n";

    LED0 = 0;
    system_state = connecting;

    while(1)
    {
        switch(system_state)
        {
            case connecting:
                /*
                 * State for connecting to the reciever via BT.
                 * 
                 * Handshaking works as follows:
                 * 1. Send the receiver our BT ID, which we grabbed from the 
                 *    BT chip before entering the state machine
                 * 2. Expect the receiver to send it's BT ID back. It's 
                 *    hardcoded in here.
                 * 
                 * When it works, we switch to the connected state. Otherwise, 
                 * retry. Maybe go to an error case. Haven't written that yet.
                 */

                // Assuming we're already in CMD mode from pre-state
                // machine stuff..

                // Reset the UART recieve buffer
                clear_recieve_buffer();

                // Fire off a connect command to the bluetooth
                SerialTransmit("C,0006664D63FA\n");
                LED1 = 0;

                // Wait for acknowledge from the BT chip
                int resp = expect_response("TRYING\r\n",2000);

                LED3 = !resp;

                
                /* We can check the status bit, #defined as CONNECTION_STATUS
                 * in order to determine if we are connected. Once we have
                 * connection, then we should proceed.
                 * 
                 * We should also dedicate one of the general purpose
                 * LEDs to the connection status, although we may want
                 * to only light it up after confirming we are connected
                 * to the right receiver bluetooth module.
                 */

                while(CONNECTION_STATUS != 1)
                {
                    LED1 = 0;
                    LED4 = 0;
                }

                LED1 = 1;
                LED4 = 1;

                // Reset the UART recieve buffer again
                clear_recieve_buffer();

                // Use the timer to wait for 10 seconds.
                // TODO: acutally poll connection state and retry if necessary
                delay(10000);

                resp = 0;
                while(resp != 1)
                {
                    // Send our BT chip's address for handshaking.
                    SerialTransmit(dev_id);

                    // Wait for the other BT chip to respond with its address
                    // TODO: use the timer to only wait a certain amount of time for
                    // response, and retry/alert the user

                    resp = expect_response("0006664D63FA\r\n",3000);

                    /*
                     * At this point, if we do not receive the response back,
                     * we may want to restard the whole state, and reset the
                     * bluetooth module. The output #defined as BLUETOOTH_RESET
                     * can accomplish it.
                     */

                    LED4 = !resp;
                }

                // If we make it here, we're connected!
                // TODO: check to make sure.

                delay(500);

                LED0 = 1;
                LED1 = 1;
                LED2 = 1;
                LED3 = 1;
                LED4 = 1;
                
                // Switch to connected state
                system_state = connected_waiting;

            case connected_waiting:
                /*
                 * State for when the BT is connected. Poll the command button,
                 * change state if warranted, rinse and repeat.
                 *
                 * Make sure that we are filtering the analog signal so that only
                 * a "real" press changes state, as opposed to an accidental
                 * press of the command button
                 */

                // placeholder til ADC is working...
                // start the timer and just wait for a bit
                delay(2000);

                LED1 = 0;

                system_state = command_active;
                


            case command_active:
                /*
                 * State for when the command button is pressed.
                 * Check the other buttons, fire the necessary command over BT,
                 * wait for ack for a certain amount of time, and retry.
                 *
                 * Since the horn will be activated for all buttons pressed,
                 * we should make sure that the user has enough time to press
                 * all buttons before we send the command. Thus we should
                 * setup some sort of timer once one of the buttons is pressed
                 * to allow more time for the user to press all buttons.
                 */

                // TODO: code to check buttons and pick command
                // for now, let's assume we're sending "1".

                // Send command over BT
                SerialTransmit("1\0");

                // wait for ACK from reciever
                // TODO: timeout logic
                resp = expect_response("ACK\n",3000);

                // temporary: wait before proceeding
                delay(1000);
        }
    }

    return (EXIT_SUCCESS);
}


void _ISR _T1Interrupt(void)
{
    // Each timer "tick" is 16ms.
    // Flip the LED to show that it's working.
    // LED4 = !LED4;

    if(timer_en == 1)
    {

        // timer variable must be set ahead of time
        // (the delay function does this)
        timer_en = 0;
        wait_hold = 0;
    }
    else if(timer > 0)
    {
        timer--;
        wait_hold = 0;
    }
    else
    {
        timer = 0;
        wait_hold = 1;
    }
    
    // Timer to check the battery, should be self triggered
    if(batt_check == 1)
    {
		battery = checkBatteryVoltage();
		batt_check = 0;
		batt_count = 0;
	}
	else if(batt_count < TEN_MIN)
		batt_count++;
	else
	{
		batt_count = 0;
		batt_check = 1;
	}	
	
	if(battery <= LOW_VOLTAGE)
	{
		// Indicate low voltage LED
	}
	else
	{
		// Turn off low voltage LED
	}	

    // Clear the interrupt flag
    IFS0bits.T1IF = 0;
}



void _ISR _U2RXInterrupt(void)
{
    // put the received character into a var
    data = U2RXREG;

    // put the char into the read buffer at the right spot
    string[read_index] = data;
    read_index++;

    next = 1;

    // Clear the RX interrupt Flag
    IFS1bits.U2RXIF = 0;
}

void delay(int wait_ms) {
    /*
     * Uses the timer interrupt to wait a given number of milliseconds.
     * Must be a multiple of 16ms (which is the timer rate), or it will
     * be rounded down to the nearest 16ms multiple.
     *
     * NOTE: this is not highly precise. It's pretty close, but allow a little
     * leeway if precision of your wait times are critical
     */

    // calculate number of timer "ticks" to put on the countdown
    timer = wait_ms/16;

    // clear the "timer is done" flag
    wait_hold = 0;

    // start the countdown (see the timer interrupt to see how this works)
    timer_en = 1;

    // wait til the countdown is done
    while(wait_hold == 0);

    return;

}


